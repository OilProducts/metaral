// Compute density and near-density for each particle using naive neighbor walk
// over a sorted range. Real range offsets will be provided by CPU-side table.
#version 450
#include "fluid_common.glsl"

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 5) buffer RangeStarts { uint starts[]; };
layout(std430, binding = 6) buffer RangeEnds   { uint ends[]; };

layout(std430, binding = 7) buffer DensityOut {
    vec2 densities[]; // x = density, y = near-density
};

layout(std430, binding = 2) buffer HashKeys {
    uint keys[];
};

// Simple 3D integer hash (same as fluid_spatial_hash.comp)
uint hash(uvec3 v) {
    v = (v + 0x7ed55d16u) + (v << 12u);
    v = (v ^ 0xc761c23cu) ^ (v >> 19u);
    v = (v + 0x165667b1u) + (v << 5u);
    v = (v + 0xd3a2646cu) ^ (v << 9u);
    v = (v + 0xfd7046c5u) + (v << 3u);
    v = (v ^ 0xb55a4f09u) ^ (v >> 16u);
    return v.x ^ v.y ^ v.z;
}

// Binary search the sorted key array for [start,end) of a cell. Returns false if missing.
bool find_range_for_key(uint key, out uint start, out uint end) {
    uint lo = 0u;
    uint hi = params.numParticles;
    while (lo < hi) {
        uint mid = (lo + hi) >> 1;
        uint k = keys[mid];
        if (k < key) {
            lo = mid + 1u;
        } else {
            hi = mid;
        }
    }
    if (lo >= params.numParticles || keys[lo] != key) {
        return false;
    }
    start = lo;
    hi = params.numParticles;
    while (lo < hi) {
        uint mid = (lo + hi) >> 1;
        if (keys[mid] > key) {
            hi = mid;
        } else {
            lo = mid + 1u;
        }
    }
    end = hi;
    return true;
}

// Poly6 kernel constants (inlined for now).
float w_poly6(float r, float h) {
    if (r >= h) return 0.0;
    float x = (h*h - r*r);
    return 315.0 / (64.0 * 3.14159265 * pow(h, 9.0)) * x * x * x;
}

float w_spiky(float r, float h) {
    if (r >= h) return 0.0;
    float x = h - r;
    return 15.0 / (3.14159265 * pow(h, 6.0)) * x * x * x;
}

void main() {
    int i = particleIndex();
    if (i < 0) return;

    uint start = starts[i];
    uint end   = ends[i];
    vec3 pi = positions_out.particles[i].position.xyz;

    float density = 0.0;
    float near_density = 0.0;
    float h = params.smoothingRadius;
    ivec3 cell = ivec3(floor(pi / h));

    for (int dz = -1; dz <= 1; ++dz) {
        for (int dy = -1; dy <= 1; ++dy) {
            for (int dx = -1; dx <= 1; ++dx) {
                uvec3 neighbor = uvec3(cell + ivec3(dx, dy, dz));
                uint key = hash(neighbor);
                uint nStart = 0u;
                uint nEnd = 0u;
                if (!find_range_for_key(key, nStart, nEnd)) {
                    continue;
                }
                for (uint j = nStart; j < nEnd; ++j) {
                    vec3 pj = positions_out.particles[j].position.xyz;
                    float r = length(pi - pj);
                    float q = r / h;
                    if (q < 1.0) {
                        density += w_poly6(r, h);
                        near_density += w_spiky(r, h);
                    }
                }
            }
        }
    }

    densities[i] = vec2(density, near_density);
}
